---
title: "Group 8 Technical Appendix"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Introduction
This Appendix will be broken down into three parts. The first will go over some general data analysis which undertaken to get a visual feel of the dataset that was being worked with, this includes loading all the data, cleaning and subsetting as required.
The second will cover the implementation of Task 1 and finally the third will cover the implementation of Task 2.

## Section 1: General EDA
```{r libraries, results= "hide", message=F, warning=F}
library(tidyverse)
library(lubridate)
library(GGally)
library(cluster)
library(VIM)
library(fpc)
library(leaps)
library(readxl)
library(cowplot)
library(corrplot)
library(readxl)
library(gridExtra)
```

Firstly, we'll setup the import the dataset and split it into training and test data.
```{r codesetup, results= "hide", message=F, warning=F}
#spotify.clustering <- read_csv("inst/edited_spotify.csv")
#Our spotify data was located within our inst folder on github -> may need to remove inst/ for it to run
spotify.clustering <- read_excel("inst/edited_spotify.xlsx")

#Cleaning the data for use
clean_data <- spotify.clustering %>%
  mutate(AlbumReleaseDate = parse_date_time(AlbumReleaseDate, orders = c("y", "ym","ymd"))) %>%
  #Old-school grepl method
  mutate(Artist = ifelse(grepl("Beyonc*", Artist), 'Beyonce', Artist)) %>%
  #Tidyverse str_detect method
  mutate(Artist = ifelse(Artist %>% 
                           str_detect("Janelle Mon*"), 'Janelle Monae', Artist)) %>%
  mutate(AlbumBestChartPosition = ifelse(AlbumBestChartPosition %>% 
                           str_detect("#N/A"), 0, AlbumBestChartPosition)) %>%
  mutate(AlbumBestChartPosition = as.numeric(AlbumBestChartPosition)) %>%
  na.omit() %>%
  mutate(id = row_number()) %>%
  mutate(id = as.character(id)) 
sapply(data, class)
# checks for missing data
aggr(clean_data) 

#Extracting the Test data which will not be used for 
test_data <- subset(clean_data, ((AlbumName == "A Girl Called Dusty") | 
                                 (AlbumName == "Action!") |
                                 (AlbumName == "Selling England By The Pound") |
                                 (AlbumName == "Carpenters") | 
                                 (AlbumName == "Ride On") |
                                 (AlbumName == "Autoamerican") |
                                 (AlbumName == "Selected Ambient Works 85-92") |    
                                 (AlbumName == "Different Class") |
                                 (AlbumName == "O") |
                                 (AlbumName == "The Elder Scrolls IV: Oblivion: Original Game Soundtrack") |
                                 (AlbumName == "AM") |
                                 (AlbumName == "An Awesome Wave")))

#Defining the training data that will be used for the models
training_data <- subset(clean_data, ((AlbumName != "A Girl Called Dusty") & 
                                     (AlbumName != "Action!") &
                                     (AlbumName != "Selling England By The Pound") &
                                     (AlbumName != "Carpenters") & 
                                     (AlbumName != "Ride On") &
                                     (AlbumName != "Autoamerican") &
                                     (AlbumName != "Selected Ambient Works 85-92") &    
                                     (AlbumName != "Different Class") &
                                     (AlbumName != "O") &
                                     (AlbumName != "The Elder Scrolls IV: Oblivion: Original Game Soundtrack") &
                                     (AlbumName != "AM") &
                                     (AlbumName != "An Awesome Wave")))

training_data_subsetted <- training_data[c("TrackDuration", "TrackDanceability",
                                 "TrackEnergy", "TrackKey", "TrackLoudness",
                                 "TrackSpeechiness", "TrackAcousticness",
                                 "TrackInstrumentalness", "TrackLiveness", "TrackValence",
                                 "TrackTempo")]
```


## General EDA

The ggpairs function is really useful to summarise all the variables in a neat readable way, in the code below only the parameter variables will be taken into consideration in the first ggpairs. In the second one, all the popularity variables will be considered.
```{r ggpairs, message=F, warning=F}
#Takes a few minutes to run
#Though there a few too many variables here to see clearly in the knitted pdf,
#however within the Rstudio Session you can zoom on the plot and then
#All the values can be seen
ggpairs_1 <- ggpairs(data = training_data_subsetted, title = "Predictor Variables")
ggpairs_1
ggpairs_2 <- ggpairs(data = training_data %>%
                       select(ArtistNumFollowers, ArtistPopularity, AlbumWeeksNumberOne,
                              AlbumBestChartPosition, AlbumWeeksOnChart),
                     title = "Popularity Variables")
ggpairs_2
```

```{r summarisies, message=F, warning=F}
MyData = {training_data %>% 
    group_by(Artist,AlbumName,AlbumReleaseDate) %>% 
    summarize(AlbumDanceability = mean(TrackDanceability),
              AlbumLoudness = mean(TrackLoudness),
              AlbumSpeechiness = mean(TrackSpeechiness),
              AlbumDuration = mean(TrackDuration),
              AlbumNumber = mean(TrackNumber),	
              AlbumEnergy = mean(TrackEnergy),	
              AlbumKey = mean(TrackKey),	
              AlbumMode = mean(TrackMode),	
              AlbumAcousticness = mean(TrackAcousticness),	
              AlbumInstrumentalness = mean(TrackInstrumentalness),	
              AlbumLiveness = mean(TrackLiveness),
              AlbumValence = mean(TrackValence),
              AlbumTempo = mean(TrackTempo),	
              AlbumTimeSignature = mean(TrackTimeSignature) )}

```

```{r albumpopularity, message=F, warning=F}
MyData2 = {training_data %>% 
    group_by(AlbumPopularity) %>% 
    summarize(AlbumDanceability = mean(TrackDanceability),
              AlbumLoudness = mean(TrackLoudness),
              AlbumSpeechiness = mean(TrackSpeechiness),
              AlbumDuration = mean(TrackDuration),
              AlbumNumber = mean(TrackNumber),	
              AlbumEnergy = mean(TrackEnergy),	
              AlbumKey = mean(TrackKey),	
              AlbumMode = mean(TrackMode),	
              AlbumAcousticness = mean(TrackAcousticness),	
              AlbumInstrumentalness = mean(TrackInstrumentalness),	
              AlbumLiveness = mean(TrackLiveness),
              AlbumValence = mean(TrackValence),
              AlbumTempo = mean(TrackTempo),	
              AlbumTimeSignature = mean(TrackTimeSignature) )}

#scatterplot function for visualising data combinations
scatter_plot <- function(x, y){
  MyData2 %>%
    ggplot(aes_string(x = x, y = y)) +
    geom_point() +
    geom_smooth() +
    theme_bw()
}

#For visualise purposes want to look at the variables versus album popularity
s1 <- scatter_plot("AlbumDanceability", " AlbumPopularity")
s2 <-scatter_plot("AlbumLoudness", "AlbumPopularity")
s3 <-scatter_plot("AlbumEnergy", "AlbumPopularity")
s4 <-scatter_plot("AlbumSpeechiness", "AlbumPopularity")
s5 <-scatter_plot("AlbumDuration", "AlbumPopularity")
s6 <-scatter_plot("AlbumNumber", "AlbumPopularity")
s7 <-scatter_plot("AlbumKey", "AlbumPopularity")
s8 <-scatter_plot("AlbumMode", "AlbumPopularity")
s9 <-scatter_plot("AlbumAcousticness", "AlbumPopularity")
s10 <-scatter_plot("AlbumInstrumentalness", "AlbumPopularity")
s11 <-scatter_plot("AlbumLiveness", "AlbumPopularity")
s12 <-scatter_plot("AlbumValence", "AlbumPopularity")
s13 <-scatter_plot("AlbumTempo", "AlbumPopularity")
s14 <-scatter_plot("AlbumTimeSignature", "AlbumPopularity")

plot_grid(s1,s2,s3,s4,s5,s6,  nrow = 3, ncol = 2)
plot_grid(s7,s8,s9,s10,s11,s12, s13,s14, nrow = 4, ncol = 2)
#End conclusions from this involve the necessity to define our own
#popularity variable using all popularity parameters
```

Looking at correlations between the variables for interest.
```{r correlations}
correlations <- round(cor(training_data_subsetted),2)
correlations

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
p.mat <- cor.mtest(training_data_subsetted)$p
corrplot(correlations, method = "color", col = col(200),
         type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 90, # Text label color and rotation
         addCoef.col = "black",
         # Combine with significance
         p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag = FALSE, tl.cex = 0.8)
```
Looking at the how the popularity of music varies over time.
```{r most popularity music type trend, message=F, warning=F}
res <- strsplit(training_data$ArtistGenres, split = ",")
uniques <- unique(unlist(res))

res2 <- NULL
for(i in 1:nrow(training_data)) {
  temp <- match(uniques, res[[i]])
  res2 <- rbind(res2, temp)
}

res2[is.na(res2)] <- 0
res2[res2 > 0] <- 1
colnames(res2) <- uniques
row.names(res2) <- 1:nrow(res2)
newdat <- data.frame(year = year(training_data$AlbumReleaseDate), 
                     popularity = training_data$ArtistPopularity,
                     res2)
means2 <- c()
for(i in 3:ncol(newdat)) {
    
    means <- aggregate(popularity ~ year ,data = newdat[newdat[,i]==1,], mean)
    means$type <- colnames(newdat)[i]
    means2 <- rbind(means2, means)
}

means21 <-   NULL
  for(i in sort( unique(means2$year))) {
  aa <- means2[ means2$year == i,]
  pos <- which.max(aa$popularity)
  means21 <-  rbind(means21 , c(i,aa$popularity[pos], aa$type[pos]))
  }

means21 = data.frame(means21)
colnames(means21) <- c("year","popularity","type")
means21$year <- as.integer(as.character(means21$year))
means21$popularity <- as.numeric(as.character(means21$popularity))

ggplot(means21, aes(year, popularity)) + geom_line(color = "indianred") + geom_point(color = "blue") + 
  theme_classic() + geom_text(aes(label = type) ,check_overlap = TRUE, size = 4, nudge_y = 0.1) + ggtitle("all time most popularity music type")
```
