---
title: "Clustering"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tibble)
library(lubridate)
library(GGally)
library(cluster)
library(class)
library(caret)
```

## Task Implementation
Done some research and kmeans is apparently quite naive - working on
an implementation with pam (and pamk). Also need to work on how we
choose the number of clusters.

```{r data clean, message=FALSE}

spotify.clustering <- read_csv("inst/edited_spotify.csv")

clean_data <- spotify.clustering %>%
  mutate(AlbumReleaseDate = parse_date_time(AlbumReleaseDate, orders = c("y", "ym","ymd"))) %>%
  #Old-school grepl method
  mutate(Artist = ifelse(grepl("Beyonc*", Artist), 'Beyonce', Artist)) %>%
  #Tidyverse str_detect method
  mutate(Artist = ifelse(Artist %>% 
                           str_detect("Janelle Mon*"), 'Janelle Monae', Artist)) %>%
  mutate(AlbumBestChartPosition = ifelse(AlbumBestChartPosition %>% 
                           str_detect("#N/A"), 0, AlbumBestChartPosition)) %>%
  na.omit() %>%
  mutate(id = row_number()) %>%
  mutate(id = as.character(id))
sapply(data, class)

aggr(clean_data) # checks for missing data

test_data <- subset(clean_data, ((AlbumName == "A Girl Called Dusty") | 
                                 (AlbumName == "Action!") |
                                 (AlbumName == "Selling England By The Pound") |
                                 (AlbumName == "Carpenters") | 
                                 (AlbumName == "Ride On") |
                                 (AlbumName == "Autoamerican") |
                                 (AlbumName == "Selected Ambient Works 85-92") |    
                                 (AlbumName == "Different Class") |
                                 (AlbumName == "O") |
                                 (AlbumName == "The Elder Scrolls IV: Oblivion: Original Game Soundtrack") |
                                 (AlbumName == "AM") |
                                 (AlbumName == "An Awesome Wave")))

training_data <- subset(clean_data, ((AlbumName != "A Girl Called Dusty") & 
                                     (AlbumName != "Action!") &
                                     (AlbumName != "Selling England By The Pound") &
                                     (AlbumName != "Carpenters") & 
                                     (AlbumName != "Ride On") &
                                     (AlbumName != "Autoamerican") &
                                     (AlbumName != "Selected Ambient Works 85-92") &    
                                     (AlbumName != "Different Class") &
                                     (AlbumName != "O") &
                                     (AlbumName != "The Elder Scrolls IV: Oblivion: Original Game Soundtrack") &
                                     (AlbumName != "AM") &
                                     (AlbumName != "An Awesome Wave")))

training_data_subsetted <- training_data[c("TrackDuration", "TrackDanceability",
                                 "TrackEnergy", "TrackKey", "TrackLoudness",
                                 "TrackSpeechiness", "TrackAcousticness",
                                 "TrackInstrumentalness", "TrackLiveness", "TrackValence",
                                 "TrackTempo")]

test_data_subsetted <- test_data[c("TrackDuration", "TrackDanceability",
                                 "TrackEnergy", "TrackKey", "TrackLoudness",
                                 "TrackSpeechiness", "TrackAcousticness",
                                 "TrackInstrumentalness", "TrackLiveness", "TrackValence",
                                 "TrackTempo")]

```


Defines the clustering of the training data
```{r clustering}
cluster_1 <- training_data_subsetted %>%
  kmeans(50,100,1)
```

```{r getter_functions}
song_name <- sample_n(test_data, 1) %>%
  select(TrackName) %>%
  as_vector()

get_row_new <- function(song_name){
  line_number <- test_data$TrackName %>%
    str_detect(song_name)
    
  return(min(which(line_number)))
}

#Function to get the nearest cluster for the *new* song
get_knn_cluster <- function(training_data_subsetted = training_data_subsetted,
                            test_data_subsetted = test_data_subsetted, song_name = song_name, k = 5){
  line_number <- get_row_new(song_name)
  tdata <- test_data_subsetted %>%
    slice(line_number)
  cluster <- cluster_1$cluster %>% as.matrix()
  as.numeric(knn(train = training_data_subsetted,
      test = tdata,
      cl = cluster, k = k, prob = TRUE )[[1]])
}

get_knn_cluster <- function(song_name = song_name, k = 5){
  line_number <- get_row_new(song_name)
  tdata <- test_data_subsetted %>%
    slice(line_number)
  cluster <- cluster_1$cluster %>% as.matrix()
  as.numeric(knn(train = training_data_subsetted,
      test = tdata,
      cl = cluster, k = k, prob = TRUE )[[1]])
}

get_cluster_rows <- function(cluster_number){
  cluster_1$cluster %>%
    enframe(name = "id") %>%
    filter(value == cluster_number) %>%
    select(id)
}

#Object of type class NULL error...hmmm when trying to use dplyr slice but works with base :O
# get_cluster <- function(row_number){
#   cluster_1$cluster[row_number]
# }

random_picker <- function(cluster_number){
  
new_song_rn <- get_cluster_rows(cluster_number) %>%
  #So here instead of randomly picking 1, would be good to
  #call another function based on the genre and say popularity?
    sample_n(1)
training_data %>%
  filter(id == as.character(new_song_rn)) %>%
  select(TrackName)
}

#sudo - subset data based on cluster and remove existing song -> then pick one of remaining songs.
pick_new_song <- function(song_name){
  cluster_number <- get_knn_cluster(song_name = song_name)
  random_picker(cluster_number)
}
pick_new_song(song_name)

#can look at following: cluster, centers, withins, size
#Could simply link each song to a cluster, pick nother song from that cluster based on a probabilty linked to popularity of the song and maybe an artist variables as well, as in pick same artist with higher prob if it is in the cluster
```

```{r knn_validation}
a <- data.frame(nrow = nrow(training_data_subsetted), ncol = 1)
for(i in 1:nrow(training_data_subsetted)){
  full_ds_test <- training_data[i,]
  full_ds_train <- training_data[-i,]
  test <-  training_data_subsetted[i,]
  train <- training_data_subsetted[-i,]
  cluster_actual <- training_data_subsetted %>%
  kmeans(3,100,1)
  cluster_actual <- cluster_actual$cluster[i] 
  cluster_1 <- train %>%
  kmeans(3,100,1)
  song_name <- full_ds_test$TrackName %>%
  as_vector()
 cluster_predicted <- get_knn_cluster(training_data_subsetted = train,
                                      test_data_subsetted = test, song_name = song_name)
 if(cluster_actual == cluster_predicted){
   a[i] <- 1
 }else{
   a[i] <- 0
 }
}

```

## Gabriels's Code
 expenential -0 is the maybe the way to go (scaled)
 database of thousands of songs - maybe be wary of outliers and such not
 simply twidderlerably parameters, raising questions so our model +how could we improve
 scaleability
 MEAN - PROVIDE SOME INFORMATION BUT LOSES ALOT OF DATAPOINTS. 
 WHY RATHER THAN ACTUAL METHOD, TALK ABOUT METHODOLOGY - MORE IMPORTANT
 think about aim of the recommendation - element of exploration - objective function
 WHAT WE FOUND OUT WHAT WE CONCLUDE AND WHAT WE RECOMMEND AND BUILD A REPORT ABOUT THAT AND SJUSTIFY WHAT WE HAVE DONE - WEEK 1 STAT INVESTICATION CYCLE
can look at following: cluster, centers, withins, size
Could simply link each song to a cluster, pick nother song from that cluster based on a probabilty linked to popularity of the song and maybe an artist variables as well, as in pick same artist with higher prob if it is in the cluster

